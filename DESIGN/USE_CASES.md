CS308 Use Cases: VOOGASalad
===================

Use cases involving design of GUIs: 

1. Application will have separate GUIs for the game editor (to create the game) and the game player (to play the game)
2. User can open multiple games without crashing 
3. User can define whether the game will be displayed 2D or 3D (isometric)
4. Allow users to customize the map size of the game, or scaling the unit size in the map (equivalent)
20. Enable wrap-around for the GUI or otherwise capping hard limits on the board for movement


Use cases involving game design: 

17. User can define what the level background image is by uploading a picture file
18. User can create path components (bridges, tunnels, etc.) that have special attributes (underlap other path components, overlap, etc.) and their attributes (image representation, money, size, etc.)
18. User can choose for the player to see the heads-up display
19. User can place scenery/aesthetic items on the map
20. User can define a main base for wave attack gameplay and attributes
18. Authoring environment should have tabs to define aspects of the games (create enemies, create turrets, load image, etc.)
19. Allow users to implement terrain on the map (changes range of towers, speed of units on board)
19. User defines the appearance of the path (with authoring environment creating a default)
19. User can define how many levels the game possesses 
20. User can define the game type (levels, survival, etc.) 
21. User can define the goal of the round (whether to kill all enemies within a time limit, or keep base alive within a time limit, or keep base alive for a certain number of enemies).
22. User defines win/lose conditions, if any (infinite levels (survival mode), defeat enemy base, campaign mode, etc.)
23. User defines what happens upon a win/lose condition being satisfied
21. User can define which enemies show up in which level 
22. User can define the spawn rate for a particular set of enemies 
23. User can define a particular order where enemies are spawned
22. User can define new troops on the board along with their attributes (health, speed, image, money given per kill, range)
23. User can define how player gains money/points (killing enemies, taking territory, bank element/constant gain for each unit time, etc.)
23. User can define whether units are specific to one faction or another (ally, player, enemy)
24. User can define new types of towers along with their attributes (health, cost, damage per attack, attack rate, image representation, upgrades/upgrade costs)
3. User can define a path that enemies take in the authoring environment
4. User can define multiple paths that enemies take in the authoring environment
4. Authoring environment can generate a random path if the user desires
6. User can define locations where the player is allowed to place towers 
7. Authoring environment restricts user in placement of where to place towers depending on the game type selected
8. User can define a boss-level enemy with special attributes (cutscene, special henchman generation, etc.)
9. User can define whether game saves high scores 
9. User can save a game to XML for future development 
10. User can save a game to XML for immediate gameplay 
18. User can define which units are available for user control 
19. User can test the game in the authoring environment indefinite number of times 
20. Authoring environment handles any errors during user testing and returns errors to user in an intuitive way
21. User can link levels together (campaign gameplay)
22. User can define win/lose scenes (default generated by the authoring environment)
23. User can define how levels are differentiated (by difficulty, environment)
24. User can link levels together to create a game
25. User can define cheat codes (automatically go to win/lose conditions, clear enemies on board, infinite money, etc.)
26. Users can define tower attack attributes (area damage, bullet, bullet with area damage, etc.)
27. User can define obstacles to be placed explicitly on the path 
28. Animate Units on the board to interact with the obstacle/aesthetic element/path element (bridge, tunnel) and override default command
29. Authoring environment can implement default sound files for units 
30. Users can override default sounds for units according to unit, action, condition, etc. 
31. Users can create and place powerups
32. Authoring environment can set game to automatically generate powerups 
1. Create barriers that paths cannot cross over 
2. Enable enemies to crush each other when they overlap (or enable allies to shoot each other)
3. Create resources to be gathered on screen (gold mine) 
4. Bundle cheats together with cutscenes or other tidbits 
5. Enable units to change from one faction to another (conversion, dart tower of truth, etc.)
6. Create a hierarchy of towers so they evolve to wholly new towers otherwise unattainable, instead of just upgrading 
7. Enable multiplayer with multiple human players on the same game 
9. Create units that can hold units (vehicles, towers that hold archers, etc.) 
10. Enable units to have some resource drain with corresponding balance in power (Tesla tower that shoots lightning bolts but also needs a steady stream of electricity/coin to operate otherwise it will go dark) 
11. Enable destructible paths given multiple paths available 
12. Enable destructible towers 
13. Power-up hierarchy with special units/towers available to the player given a chosen hierarchy (range, melee, etc.) 
14. Create a Dungeons vs. Dragons type tower defense (vertical instead of horizontal) 
15. Units that can dynamically change size while on the board, or divide into multiple units (e.g. bacteria units)
16. Enable regions on the map where units can have reduced health damage (trenches)
17. Automatically upgrade units based on the level achieved, with corresponding attribute benefits (e.g. veterancy with greater accuracy) 
18. Units that help other units on the board (medic that heals, officer to increase morale, etc.) 
19. Have starting and ending points in the middle of the map (e.g. mole unit that borrows up through the ground) 

Use cases involving gameplay: 

8. Player can drag and drop items onto the board during gameplay
20. Player can choose when to advance to the next round/level
1. Player can upgrade turrets and troops during game (after each wave the engine generates a popup screen to display options available)
2.  Player can buy his own troops to send out; they travel backward on the path and collide with enemy troops
2. Player can take control of user-controllable units on the map
15. Player can use cheat codes for different benefits (win, lose, gain money, less enemies, etc.)
20. Visually show the tower range on the map when the user is placing a tower on the map

Use cases involving game resources for the player: 

8. Authoring environment should have a HTML formatted help page for user that describes the components of the authoring environment. 
9. User can load a previously saved game and play it
10. User can see which games are available, including at least each game's name, image, and description
11. User can write a ‘Rules’ dialog that the player can open up during gameplay that describes how to play the game

Use cases involving miscellaneous: 

19. Be able to run a client-server/SOA model for the game (remote Java server on AWS) 
21. Sync different kinds of I/O (such as Kinect, Leap Motion, Myo) to the game so no fixed need on a keyboard and mouse



